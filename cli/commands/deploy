#!/usr/bin/env bash

declare="${ECHO_PREFIX:=}"
declare="${GREEN:=}"
declare="${YELLOW:=}"
declare="${RED:=}"
declare="${CYAN:=}"
declare="${WHITE:=}"
declare="${RESET:=}"
declare="${LESS:=}"
declare="${BOX_PROJECT_DIR:=}"
declare="${BOX_PROJECT_FILE:=}"

function deploy_help() {
	cat <<EOF

${YELLOW}WPLib Box ${GREEN}CLI${RESET} ${GREEN}deploy${RESET} usage:

box ${YELLOW}deploy${RESET}	                - Show this help.
box ${YELLOW}deploy ${GREEN}help${RESET}		        - Show this help.
box ${YELLOW}deploy ${RESET}[${CYAN}<host>]${RESET}	        - Deploys the host as defined in ${GREEN}project.json${RESET}.
box ${YELLOW}deploy unlock ${RESET}[${CYAN}<host>]${RESET}	- Unlocks a host locked for deploy ${YELLOW}[CAUTION!]${RESET}

EOF
}

function deploy_host() {

    ensure_box_tmp
    local DEPLOY_LOG="/tmp/box-tmp/deploy.log"
    rm -rf "${DEPLOY_LOG}"

    initErrorFile

    local host_id="$1"

    if [ "" == "${host_id}" ]; then
        output "Hostname required when calling 'deploy'"
        exit
    fi

    lock_deploy "${host_id}"
    exitOnError

    check_deploy_host "${host_id}"
    exitOnError

    source_url="$(get_source_repo_url)"
    exitOnError

    source_dir="$(get_raw_repo_cache_dir "${source_url}")"
    exitOnError

    source_branch="$(get_source_repo_branch "${host_id}")"
    exitOnError

    deploy_url="$(get_raw_host_repo_url "${host_id}")"
    exitOnError

    deploy_dir="$(get_raw_repo_cache_dir "${deploy_url}")"
    exitOnError

    deploy_branch="$(get_raw_deploy_host_branch "${host_id}")"
    exitOnError

    ################ensure_no_uncommitted_files

    output
    output "${YELLOW}Preparing to deploy:${RESET}"
    output
    output "   ${CYAN}Source branch: ${GREEN}${source_branch}${RESET}"
    output "   ${CYAN}Source repo:   ${GREEN}${source_url}${RESET}"
    output
    output "   ${CYAN}Deploy branch: ${GREEN}${deploy_branch}${RESET}"
    output "   ${CYAN}Deploy repo:   ${GREEN}${deploy_url}${RESET}"
    output

    output "   ${YELLOW}Updating repository caches...${RESET}"

    ensure_repo_cached_locally "${source_url}" "${source_branch}" >> $DEPLOY_LOG 2>&1

    ensure_repo_cached_locally "${deploy_url}" "${deploy_branch}" >> $DEPLOY_LOG 2>&1

    output "   ${YELLOW}Running Composer Install on source...${RESET}"

    ensure_source_composer_install "${source_dir}" >> $DEPLOY_LOG 2>&1

    #
    # Sync vendor path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "$(get_raw_source_wp_vendor_path)" \
        "$(get_raw_deploy_wp_vendor_path)"  >> $DEPLOY_LOG

    #
    # Sync content path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "$(get_raw_source_wp_content_path)" \
        "$(get_raw_deploy_wp_content_path)"  >> $DEPLOY_LOG

    local wp_source_core_path="$(get_raw_source_wp_core_path)"
    local wp_deploy_core_path="$(get_raw_deploy_wp_core_path)"

    #
    # Sync core wp-admin path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "${wp_source_core_path}/wp-admin" \
        "${wp_deploy_core_path}/wp-admin"  >> $DEPLOY_LOG

    #
    # Sync core wp-includes path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "${wp_source_core_path}/wp-includes" \
        "${wp_deploy_core_path}/wp-includes"  >> $DEPLOY_LOG

    #
    # Sync core root files
    # Copy *just* the files in www/blog/ and not subdirectories
    # See: https://askubuntu.com/a/632102/486620
    #
    sync_files_shallow \
        "${source_dir}" \
        "${deploy_dir}" \
        "${wp_source_core_path}" \
        "${wp_deploy_core_path}"  >> $DEPLOY_LOG

    remove_deploy_delete_files "${deploy_dir}"  >> $DEPLOY_LOG
exit

    # Sort by https://stackoverflow.com/a/5917762/102699
    last_build="$(echo -e $deploy_tags | grep -v deploy-lock | awk '{ print length, $2 }' | sort -r -n | cut -d" " -f2- | head -n 1 | sed -e 's#^refs/tags/##')"

    #git add.
    #commit

    echo "Deploy complete."

}

function lock_deploy() {
    result="success"
    local host_id="$1"
    local lock_slug="$(get_git_deploy_lock_slug "${host_id}")"
    local deploy_lock="$(TrimSpace "$(get_git_deploy_lock "${host_id}")")"
    if ! [ "" != "{$deploy_lock}" ]; then
        result="fail"
    else
        lock_git_deploy "${host_id}"
        if [ "0" != "$?" ] ; then
            result="fail"
        fi
    fi
    if [ "fail" == "${result}" ] ; then
        alert ""
        alert "${RED}Your current Git repository already has a ${GREEN}deploy lock${RED}. Cannot deploy.${RESET}"
        alert ""
        alert "If you know this lock to be in error you can delete with this command:"
        alert ""
        alert "\t${GREEN}box deploy unlock ${host_id}${RESET}"
        alert ""
        alert "However, ${YELLOW}caution is in order${RESET}. If you attempt to run a deploy while"
        alert "another is running ${RED}expect the unexpected${RESET}."
        alert ""
        alert "P.S. A deploy lock is a Git 'tag' whose name is 'deploy-lock-*' where '*'"
        alert "contains your deploy host and your email address, e.g:"
        alert ""
        alert "\t${GREEN}${lock_slug}${RESET}"
        alert ""
        exit 1
    fi
}

function deploy_unlock_host() {
    local host_id="$1"
    local user_email="$(get_raw_user_email)"
    if [ "" == "${user_email}" ] ; then
        box user show
        exit 1
    fi

    unlock_git_deploy "${host_id}"
    if [ "0" != "$?" ] ; then
        local lock_slug="$(get_git_deploy_lock_slug "${host_id}")"
        alert "Deploy ${GREEN}${host_id}${RESET} unlocked ${RED}FAILED${RESET}."
        alert "Try these commands and Google the error messages to diagnose:"
        alert ""
        alert "\t${GREEN}git push origin :refs/tags/${lock_slug}${RESET}"
        alert "\t${GREEN}git tag -d ${lock_slug}${RESET}"
        alert ""
        alert "Also feel free to reach out to our SLack support for help."
        alert ""
        exit 1
    fi
    output "Deploy ${GREEN}${host_id}${RESET} unlocked."
}


function remove_deploy_delete_files() {
    local deploy_dir="$1"
    checkParam "${deploy_dir}" "You must pass a destination directory as 1st argument to remove_deploy_delete_files()."
    exitOnError

    local exclude_files="$(get_raw_deploy_delete_files)"
    local saveIFS="${IFS}"
    IFS=$'\n'
    for file in $exclude_files ; do
        file="${deploy_dir}${file}"
        if [ "" == "$(ls -A ${file} 2>/dev/null)" ] ; then
            echo "Skipping deletion of ${file} [File not found.]"
            continue
        fi
        echo "Deleting ${file}"
        rm -rf "${file}"
    done
    IFS="${saveIFS}"
}

function sync_files_shallow() {

    local source_dir="$1"
    checkParam "${source_dir}" "You must pass a source directory as 1st argument to sync_files_shallow()."
    exitOnError

    local deploy_dir="$2"
    checkParam "${deploy_dir}" "You must pass a destination directory as 2nd argument to sync_files_shallow()."
    exitOnError

    local source_path="$3"
    checkParam "${source_path}" "You must pass a source path as 3rd argument to sync_files_shallow()."
    exitOnError

    local deploy_path="$4"
    checkParam "${deploy_path}" "You must pass a destination path as 4th argument to sync_files_shallow()."
    exitOnError

    local exclude_files_list="$(write_sync_exclude_files_by "path" "${source_path}")"

    rsync --archive --filter="- */" --filter="+ *" --exclude-from="${exclude_files_list}" \
        "$(RTrimSlashes "${source_dir}${source_path}")" \
        "$(RTrimSlashes "${deploy_dir}${deploy_path}")"

}

function sync_files_deep() {
    local source_dir="$1"
    checkParam "${source_dir}" "You must pass a source directory as 1st argument to sync_files_deep()."

    local deploy_dir="$2"
    checkParam "${deploy_dir}" "You must pass a destination directory as 2nd argument to sync_files_deep()."
    exitOnError

    local source_path="$3"
    checkParam "${source_path}" "You must pass a source path as 3rd argument to sync_files_deep()."
    exitOnError

    local deploy_path="$4"
    checkParam "${deploy_path}" "You must pass a destination path as 4th argument to sync_files_deep()."
    exitOnError

    local exclude_files_list="$(write_sync_exclude_files_by "path" "${source_path}")"

    rsync --archive --delete-after --verbose \
        --exclude ".git" --exclude ".git*" --exclude-from="${exclude_files_list}" \
        "${source_dir}${source_path}/" \
        "${deploy_dir}${deploy_path}"

    rm -rf "${exclude_files_list}"

}

function get_raw_deploy_exclude_files() {
    local exclude="$(get_raw_deploy | jqr ".files.exclude[]")"
    echo "${exclude}"
}

function get_raw_deploy_delete_files() {
    local exclude="$(get_raw_deploy | jqr ".files.delete[]")"
    echo "${exclude}"
}

function write_sync_exclude_files_by() {
    local by="$1"
    local value="$2"

    mkdir -p /tmp/box-tmp/
    local exclude_file_list="$(mktemp /tmp/box-tmp/exclude-XXXX.txt)"
    touch "${exclude_file_list}"
    local exclude_files="$(get_sync_exclude_files)"
    if [ "" != "${value}" ] ; then
        case "${by}" in
        'path')
            saveIFS="${IFS}"
            IFS=$'\n'
            for file in $exclude_files ; do
                if [ "/" == "${file:0:1}" ] ; then
                    # if not an absolute reference, then file is to be excludes everywhere
                    echo -e "${file}" >> $exclude_file_list
                    continue
                fi
                if ! [[ ${file} =~ ^${value}/(.+)$ ]] ; then
                    continue
                fi
                echo -e "/${BASH_REMATCH[1]}" >> $exclude_file_list
            done
            IFS="${saveIFS}"
            ;;

        *)
            alert "The criteria [${by}] is not valid for get_sync_exclude_files_by()"
            exit 1
            ;;

        esac
    fi
    echo "${exclude_file_list}"
}

function get_sync_exclude_files() {
    local exclude_files="$(get_raw_deploy_exclude_files)\n$(get_raw_deploy_delete_files)\n$(get_raw_deploy_keep_files)"
    echo -e "${exclude_files}"
}

function ensure_source_composer_install() {
    local repo_dir="$1"
    checkParam "${repo_dir}" "You must pass a repository directory as 1st argument to ensure_source_composer_install()."
    exitOnError
    output "Running Composer to install externals."
    pushDir
    cd "${repo_dir}"
    composer install
    exitOnError
    popDir
}

function simplify_pantheon_repo_cache_dir() {
    local repo_url="$1"
    checkParam "${repo_url}" "You must pass a repository URL as 1st argument to simplify_pantheon_repo_cache_dir()."
    exitOnError
    local provider="$(get_raw_project_file | jq -r '.deploy.provider')"
    if [ "pantheon" == "${provider}" ] ; then
        local site_id="$(get_raw_project_file | jq -r '.deploy.site_id')"
        local site_name="$(get_raw_project_file | jq -r '.deploy.site_name')"
        repo_url="${repo_url//\.${site_id}/}"    # Replace guid with URL name
        repo_url="${repo_url//\/2222\/~\/repository/\/${site_name}}"  # Remove goggledegook
    fi
    echo "${repo_url}"
}

function make_cache_dir() {
    cache_dir="$1"
    mkdir --parents "${cache_dir}"
}

function get_raw_repo_cache_dir() {
    declare=${BOX_CACHE_DIR:=}
    local repo_url="$1"
    checkParam "${repo_url}" "You must pass a repository URL as 1st argument to get_raw_repo_cache_dir()."
    exitOnError
    local path="${repo_url}"
    path="${repo_url#*://}"     # Strip leading protocol; ssh://, https://, http://
    path="${path#*@}"    # Strip leading username, e.g. git@
    path="${path%.git*}"        # Strip trailing .git extension
    path="${path/:/\/}"         # Replace ':' with '/'
    local cache_dir="${BOX_CACHE_DIR}/${path}"
    cache_dir="$(simplify_pantheon_repo_cache_dir "${cache_dir}")"
    echo "${cache_dir}"
}

function check_deploy_host() {
    local host_id="$1"
    checkParam "${host_id}" "You must pass a host name/id as 1st argument to check_deploy_host()."
    exitOnError
    echo "$(get_deploy_host "${host_id}")" > /dev/null
}

function get_deploy_host() {
    local host_id="$1"
    checkParam "${host_id}" "You must pass a host name/id as 1st argument to get_deploy_host()."
    exitOnError
    json="$(cat "${BOX_PROJECT_FILE}" | jq -r ".deploy.hosts.${host_id}?")"
    if [ "object" != "$(echo "${json}"|jqr 'type')" ]; then
        alert ""
        alert "ERROR: ${RED}Your ${GREEN}project.json${RED} file does not define a host named ${YELLOW}\"${GREEN}${host_id}${YELLOW}\"${RED}.${RESET}"
        alert ""
        alert "Please edit your ${GREEN}project.json${RESET} file and add ${YELLOW}\"${GREEN}${host_id}${YELLOW}\"${RESET} as a property of ${GREEN}.hosts.${RESET}"
        alert ""
        exit 1
    fi
    echo -e "${json}"
}

function get_source_repo_url() {
    local source_repo_url="$(get_raw_source_repo_url)"
    local remote_repo_url="$(get_git_origin_remote_repo_url)"
    if [[ "${source_repo_url}" =~ ^ssh:// ]]; then
        source_repo_url="${source_repo_url#*//}"
    fi
    if [ "${source_repo_url}" != "${remote_repo_url}" ]; then
        alert ""
        alert "${RED}Your source repo and your git remote repo do not match. Cannot deploy.${RESET}"
        alert ""
        alert "\t${CYAN}Source: ${GREEN}${source_repo_url}${RESET}"
        alert "\t${CYAN}Remote: ${GREEN}${remote_repo_url}${RESET}"
        alert ""
        alert "Your source repo is found in ${GREEN}${BOX_PROJECT_FILE}${RESET} as ${GREEN}.source.repository.url.${RESET}"
        alert "Your remote is found by running ${GREEN}git remote -v${RESET}. If you are in the correct directory you"
        alert "can set your remote to match your source with:"
        alert ""
        alert "\t${GREEN}git remote set-url --push origin ${source_repo_url}${RESET}"
        alert ""
        alert "However, ${GREEN}caution is in order${RESET}. We can only give you hints about how you can resolve"
        alert "this issue, but your circumstances might require another solution, and Git can be"
        alert "a rather unforgiving beast if you do the wrong thing. So measure twice, cut once!${RESET}"
        alert ""
        exit 1
    fi
    echo "${source_repo_url}"
}

function get_source_repo_branch() {
    local host_id="$1"
    local project_branch="$(get_raw_source_branch_by "host" "${host_id}")"
    exitOnError
    local current_branch="$(get_current_git_branch)"
    exitOnError
    if [ "null" == "${project_branch}" ] ; then
        project_branch="n/a"
    fi
    if [ "${current_branch}" != "${project_branch}" ]; then
        alert ""
        alert "${RED}Your current branch does not match the deploy branch for the ${GREEN}${host_id}${RED} host."
        alert "Cannot deploy.${RESET}"
        alert ""
        alert "\t${CYAN}Current Branch: ${GREEN}${current_branch}${RESET}"
        alert "\t${CYAN}Requested Deploy Host: ${GREEN}${host_id}${RESET}"
        alert "\t${CYAN}Deploy branch for host ${RED}${host_id}${RESET}: ${GREEN}${project_branch}${RESET}"
        alert ""
        if [ "n/a" == "${project_branch}" ] ; then
            alert "${RED}Review your project.json file to ensure you have a host ${GREEN}${host_id}${RED} defined in"
            alert "the ${GREEN}.host${RED} section.${RESET}"
        else
            alert "${YELLOW}You can set switch to the project branch for host ${GREEN}${host_id}${YELLOW}, assuming \nall files in your current branch have been committed using:${RESET}"
            alert ""
            alert "\t${GREEN}git checkout ${project_branch}${RESET}"
        fi
        alert ""
        exit 1
    fi
    echo "${current_branch}"
}

function ensure_no_uncommitted_files() {
    local uncommitted_files="$(get_git_uncommitted_files)"
    local file
    if [ "" != "${uncommitted_files}" ]; then
        alert ""
        alert "${RED}Your current branch has uncommitted files. Cannot deploy.${RESET}"
        alert ""
        saveIFS="${IFS}"
        IFS=$'\n'
        for file in $uncommitted_files ; do
            alert "\t${GREEN}${file}${RESET}"
        done
        IFS="${saveIFS}"
        alert ""
        exit 1
    fi
}

function ensure_box_tmp() {
    mkdir -p /tmp/box-tmp/
}

################################################################################
CMD="$1"
shift
case $CMD in
    'unlock')
        deploy_unlock_host "$1"
        ;;

	*|'help')

        if [ "" == "${CMD}" ] ; then
            deploy_help
            exit 1
        fi
        deploy_host "${CMD}"
		;;
esac

