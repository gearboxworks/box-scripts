#!/usr/bin/env bash

declare="${ECHO_PREFIX:=}"
declare="${GREEN:=}"
declare="${YELLOW:=}"
declare="${RED:=}"
declare="${CYAN:=}"
declare="${WHITE:=}"
declare="${RESET:=}"
declare="${LESS:=}"
declare="${DEPLOY_LOG:=}"
declare="${BOX_PROJECT_DIR:=}"
declare="${BOX_PROJECT_FILE:=}"
declare="${BOX_DEPLOY_LOCK_SLUG:=}"


function deploy_help() {
	cat <<EOF

${YELLOW}WPLib Box ${GREEN}CLI${RESET} ${GREEN}deploy${RESET} usage:

box ${YELLOW}deploy${RESET}	                - Show this help.
box ${YELLOW}deploy ${GREEN}help${RESET}		        - Show this help.
box ${YELLOW}deploy ${RESET}[${CYAN}<host>]${RESET}	        - Deploys the host as defined in ${GREEN}project.json${RESET}.
box ${YELLOW}deploy unlock ${RESET}[${CYAN}<host>]${RESET}	- Unlocks a host locked for deploy ${YELLOW}[CAUTION!]${RESET}

EOF
}


function deploy_host() {

    initErrorFile

    local host_id="$1"

    if [ "" == "${host_id}" ]; then
        output "Hostname required when calling 'deploy'"
        exit
    fi


    check_deploy_host "${host_id}"
    exitOnError

    lock_deploy
    exitOnError

    source_url="$(get_source_repo_url)"
    exitOnError

    source_dir="$(get_raw_repo_cache_dir "${source_url}")"
    exitOnError

    source_branch="$(get_source_repo_branch "${host_id}")"
    exitOnError

    deploy_url="$(get_raw_host_repo_url "${host_id}")"
    exitOnError

    deploy_dir="$(get_raw_repo_cache_dir "${deploy_url}")"
    exitOnError

    deploy_branch="$(get_raw_deploy_host_branch "${host_id}")"
    exitOnError

    ensure_no_uncommitted_files
    exitOnError

    output
    output "${YELLOW}Preparing to deploy:${RESET}"
    output
    output "   ${CYAN}Source branch: ${GREEN}${source_branch}${RESET}"
    output "   ${CYAN}Source repo:   ${GREEN}${source_url}${RESET}"
    output
    output "   ${CYAN}Deploy branch: ${GREEN}${deploy_branch}${RESET}"
    output "   ${CYAN}Deploy repo:   ${GREEN}${deploy_url}${RESET}"
    output

    output "   Updating repository caches..."

    cache_repo_locally "${source_url}" "${source_branch}" >> $DEPLOY_LOG 2>&1

    cache_repo_locally "${deploy_url}" "${deploy_branch}" >> $DEPLOY_LOG 2>&1

    output "   Running composer install..."

    run_composer_install "${source_dir}" >> $DEPLOY_LOG 2>&1
    exitOnError

    output "   Syncing updated and/or new source files..."
    #
    # Sync vendor path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "$(get_raw_source_wp_vendor_path)" \
        "$(get_raw_deploy_wp_vendor_path)"  >> $DEPLOY_LOG

    #
    # Sync content path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "$(get_raw_source_wp_content_path)" \
        "$(get_raw_deploy_wp_content_path)"  >> $DEPLOY_LOG

    local wp_source_core_path="$(get_raw_source_wp_core_path)"
    local wp_deploy_core_path="$(get_raw_deploy_wp_core_path)"

    #
    # Sync core wp-admin path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "${wp_source_core_path}/wp-admin" \
        "${wp_deploy_core_path}/wp-admin"  >> $DEPLOY_LOG

    #
    # Sync core wp-includes path files
    #
    sync_files_deep "${source_dir}" "${deploy_dir}" \
        "${wp_source_core_path}/wp-includes" \
        "${wp_deploy_core_path}/wp-includes"  >> $DEPLOY_LOG

    #
    # Sync core root files
    # Copy *just* the files in www/blog/ and not subdirectories
    # See: https://askubuntu.com/a/632102/486620
    #
    sync_files_shallow \
        "${source_dir}" \
        "${deploy_dir}" \
        "${wp_source_core_path}" \
        "${wp_deploy_core_path}"  >> $DEPLOY_LOG

    output "   Removing blacklisted files..."

    remove_deploy_delete_files "${deploy_dir}"  >> $DEPLOY_LOG
    exitOnError

    output "   Writing 'DEPLOY' files..."

    #
    # Write and commit a DEPLOY file with sequential number of latest deploy.
    #
    add_next_deploy_file  "${host_id}"
    exitOnError

    #
    # Copy the deploy lock to source_dir cache to deploy_dir cache
    #
    copy_file "$(get_deploy_filename)" "${source_dir}"
    exitOnError

    copy_file "$(get_deploy_filename)" "${deploy_dir}"
    exitOnError

    # Need to commit files here

    output "   Tagging this deploy..."

    tag_this_deploy "${host_id}" "${BOX_PROJECT_DIR}"  quiet
    exitOnError

    tag_this_deploy "${host_id}" "${deploy_dir}" quiet
    exitOnError

    output "   Deploy tagged as $(get_current_deploy_tag)."
    output "   Unlocking deploy."

    deploy_unlock quiet
    exitOnError

    #git add.
    #commit

    output "   Deploy complete."
    output ""

}

function get_current_deploy_num() {
    PushDir "${BOX_PROJECT_DIR}"
    filename="$(get_deploy_filename)"
    PopDir
    cat "${filename}"
}

function add_next_deploy_file() {
    local host_id="$1"
    PushDir "${BOX_PROJECT_DIR}"
    local deploy_num="$(get_git_next_deploy_num)"
    exitOnError
    filename="$(get_deploy_filename)"
    echo "${deploy_num}" > $filename
    if [ "0" != "$?" ] ; then
        alert ""
        alert "${RED}Could not write DEPLOY file. Deploy failed${RESET}."
        alert ""
        alert "\t${CYAN}Filename: ${GREEN}${filename}${RESET}"
        alert ""
        suggest_help_on_slack
        PopDir
        return 1
    fi

    #
    # Generates return values 1 thru 4 on error
    #
    message="$(git_raw_add_commit_push "${host_id}" "${BOX_PROJECT_DIR}" "$(basename "${filename}")")"
    result="?$"
    if [ "0" != "${result}" ] ; then
        PopDir
        return 0
    fi
    case "${result}" in
    1)
        message="${RED}Could not add ${GREEN}${filename}${RED} to local repo. Cannot deploy${RESET}."
        ;;
    2)
        message="${RED}Could not commit ${GREEN}${filename}${RED} to local repo. Cannot deploy${RESET}."
        ;;
    3)
        message="${RED}Error pulling commits from remote repo at origin. Cannot deploy${RESET}."
        ;;
    4)
        message="${RED}Could not push commit of ${GREEN}${filename}${RED} to remote repo at origin. Cannot deploy${RESET}."
        ;;
    *)
        result=0
    esac
    if [ "0" != "${result}" ] ; then
        alert ""
        alert "${message}"
        alert ""
        suggest_help_on_slack
    fi
    PopDir
    return "${result}"

}

function get_current_deploy_tag() {
    local deploy_num="$(get_current_deploy_num)"
    echo "$(get_deploy_tag "${deploy_num}")"
}

function get_deploy_tag() {
    local deploy_num="$1"
    local deploy_tag="deploy-${deploy_num}"
    echo "${deploy_tag}"
}

function tag_this_deploy() {
    local host_id="$1"
    local repo_dir="$2"
    local quiet="$3"
    local filename="$(get_deploy_filename "${repo_dir}")"
    deploy_tag="$(git_raw_tag_deploy "${host_id}" "${repo_dir}")"
    result="$?"
    case "${result}" in
    1)
        message="${RED}Deploy file ${GREEN}${filename}${RED} not written. Cannot deploy${RESET}."
        ;;
    2)
        message="${RED}Could not add ${GREEN}${filename}${RED} to local repo. Cannot deploy${RESET}."
        ;;
    3)
        message="${RED}Could not commit ${GREEN}${filename}${RED} to local repo. Cannot deploy${RESET}."
        ;;
    4)
        message="${RED}Error pulling commits from remote repo at origin. Cannot deploy${RESET}."
        ;;
    5)
        message="${RED}Could not push commit of ${GREEN}${filename}${RED} to remote repo at origin. Cannot deploy${RESET}."
        ;;
    6)
        message="${RED}Could not tag deploy locally with ${GREEN}${deploy_tag}${RED}. Cannot deploy${RESET}."
        ;;
    7)
        message="${RED}Could not tag deploy remotely at origin with ${GREEN}${deploy_tag}${RED}. Cannot deploy${RESET}."
        ;;
    *)
        result=0
    esac
    if [ "0" == "${result}" ] ; then
        if [ "" == "${quiet}" ] ; then
            output ""
            output "Deploy tagged as ${GREEN}${deploy_tag}${RESET}."
            output ""
        fi
    else
        alert ""
        alert "${message}"
        alert ""
        suggest_help_on_slack
    fi
    return "${result}"
}

function get_deploy_filename() {
    local dir="$1"
    if [ "" == "${dir}" ] ; then
        dir="${BOX_PROJECT_DIR}"
    fi
    echo "${dir}/DEPLOY"
}

function lock_deploy() {
    result="success"
    if ! [ "" != "${BOX_DEPLOY_LOCK_SLUG}" ]; then
        result="fail"
    else
        local user_name="$(get_user_display_name)"
        if [ "" == "${user_name}" ] ; then
            box user show
            exit 1
        fi
        lock_git_deploy "${user_name}"
        if [ "0" != "$?" ] ; then
            result="fail"
        fi
    fi
    if [ "fail" == "${result}" ] ; then
        alert ""
        alert "${RED}Your current Git repository already has a ${GREEN}deploy lock${RED}. Cannot deploy.${RESET}"
        alert ""
        alert "If you know this lock to be in error you can delete with this command:"
        alert ""
        alert "\t${GREEN}box deploy unlock${RESET}"
        alert ""
        alert "However, ${YELLOW}caution is in order${RESET}. If you attempt to run a deploy while"
        alert "another is running ${RED}expect the unexpected${RESET}."
        alert ""
        alert "P.S. A deploy lock is simply a Git 'tag' whose name is:"
        alert ""
        alert "\t${GREEN}deploy-lock${RESET}"
        alert ""
        return 2
    fi
}

function deploy_unlock() {
    local quiet="$1"
    unlock_git_deploy
    if [ "0" != "$?" ] ; then
        alert ""
        alert "Deploy unlock ${RED}FAILED${RESET}."
        alert "Try these commands and then Google any error messages to diagnose:"
        alert ""
        alert "\t${GREEN}git push origin :refs/tags/${BOX_DEPLOY_LOCK_SLUG}${RESET}"
        alert "\t${GREEN}git tag -d ${BOX_DEPLOY_LOCK_SLUG}${RESET}"
        alert ""
        suggest_help_on_slack
        return 1
    fi
    if [ "" == "${quiet}" ] ; then
        output ""
        output "Deploy ${GREEN}unlocked${RESET}."
        output ""
    fi
}

function remove_deploy_delete_files() {
    local deploy_dir="$1"
    checkParam "${deploy_dir}" "You must pass a destination directory as 1st argument to remove_deploy_delete_files()."
    exitOnError

    local exclude_files="$(get_raw_deploy_delete_files)"
    local saveIFS="${IFS}"
    IFS=$'\n'
    for file in $exclude_files ; do
        file="${deploy_dir}${file}"
        if [ "" == "$(ls -A ${file} 2>/dev/null)" ] ; then
            echo "Skipping deletion of ${file} [File not found.]"
            continue
        fi
        echo "Deleting ${file}"
        rm -rf "${file}"
    done
    IFS="${saveIFS}"
}

function copy_file() {
    local from_file="$1"
    local to_dir="$2"
    cp "${from_file}" "${to_dir}"
    if [ "0" != "$?" ] ; then
        alert ""
        alert "${RED}Could not copy the DEPLOY market file to the cached repo directory. Cannot deploy.${RESET}"
        alert ""
        alert "\t${CYAN}Copy: ${GREEN}${from_file}${RESET}"
        alert "\t${CYAN}To:   ${GREEN}${to_dir}${RESET}"
        alert ""
        suggest_help_on_slack
        exit 1
    fi

}

function sync_files_shallow() {

    local source_dir="$1"
    checkParam "${source_dir}" "You must pass a source directory as 1st argument to sync_files_shallow()."
    exitOnError

    local deploy_dir="$2"
    checkParam "${deploy_dir}" "You must pass a destination directory as 2nd argument to sync_files_shallow()."
    exitOnError

    local source_path="$3"
    checkParam "${source_path}" "You must pass a source path as 3rd argument to sync_files_shallow()."
    exitOnError

    local deploy_path="$4"
    checkParam "${deploy_path}" "You must pass a destination path as 4th argument to sync_files_shallow()."
    exitOnError

    local exclude_files_list="$(write_sync_exclude_files_by "path" "${source_path}")"

    rsync --archive --filter="- */" --filter="+ *" --exclude-from="${exclude_files_list}" \
        "$(RTrimSlashes "${source_dir}${source_path}")" \
        "$(RTrimSlashes "${deploy_dir}${deploy_path}")"

}

function sync_files_deep() {
    local source_dir="$1"
    checkParam "${source_dir}" "You must pass a source directory as 1st argument to sync_files_deep()."

    local deploy_dir="$2"
    checkParam "${deploy_dir}" "You must pass a destination directory as 2nd argument to sync_files_deep()."
    exitOnError

    local source_path="$3"
    checkParam "${source_path}" "You must pass a source path as 3rd argument to sync_files_deep()."
    exitOnError

    local deploy_path="$4"
    checkParam "${deploy_path}" "You must pass a destination path as 4th argument to sync_files_deep()."
    exitOnError

    local exclude_files_list="$(write_sync_exclude_files_by "path" "${source_path}")"

    rsync --archive --delete-after --verbose \
        --exclude ".git" --exclude ".git*" --exclude-from="${exclude_files_list}" \
        "${source_dir}${source_path}/" \
        "${deploy_dir}${deploy_path}"

    rm -rf "${exclude_files_list}"

}

function get_raw_deploy_exclude_files() {
    local exclude="$(get_raw_deploy | jqr ".files.exclude[]")"
    echo "${exclude}"
}

function get_raw_deploy_delete_files() {
    local exclude="$(get_raw_deploy | jqr ".files.delete[]")"
    echo "${exclude}"
}

function write_sync_exclude_files_by() {
    local by="$1"
    local value="$2"

    mkdir -p /tmp/box-tmp/
    local exclude_file_list="$(mktemp /tmp/box-tmp/exclude-XXXX.txt)"
    touch "${exclude_file_list}"
    local exclude_files="$(get_sync_exclude_files)"
    if [ "" != "${value}" ] ; then
        case "${by}" in
        'path')
            saveIFS="${IFS}"
            IFS=$'\n'
            for file in $exclude_files ; do
                if [ "/" == "${file:0:1}" ] ; then
                    # if not an absolute reference, then file is to be excludes everywhere
                    echo -e "${file}" >> $exclude_file_list
                    continue
                fi
                if ! [[ ${file} =~ ^${value}/(.+)$ ]] ; then
                    continue
                fi
                echo -e "/${BASH_REMATCH[1]}" >> $exclude_file_list
            done
            IFS="${saveIFS}"
            ;;

        *)
            alert "The criteria [${by}] is not valid for get_sync_exclude_files_by()"
            exit 1
            ;;

        esac
    fi
    echo "${exclude_file_list}"
}

function get_sync_exclude_files() {
    local exclude_files="$(get_raw_deploy_exclude_files)\n$(get_raw_deploy_delete_files)\n$(get_raw_deploy_keep_files)"
    echo -e "${exclude_files}"
}

function run_composer_install() {
    local repo_dir="$1"
    checkParam "${repo_dir}" "You must pass a repository directory as 1st argument to run_composer_install()."
    exitOnError
    output "Running Composer to install externals."
    PushDir
    cd "${repo_dir}"
    composer install
    exitOnError
    PopDir
}

function simplify_pantheon_repo_cache_dir() {
    local repo_url="$1"
    checkParam "${repo_url}" "You must pass a repository URL as 1st argument to simplify_pantheon_repo_cache_dir()."
    exitOnError
    local provider="$(get_raw_project_file | jq -r '.deploy.provider')"
    if [ "pantheon" == "${provider}" ] ; then
        local site_id="$(get_raw_project_file | jq -r '.deploy.site_id')"
        local site_name="$(get_raw_project_file | jq -r '.deploy.site_name')"
        repo_url="${repo_url//\.${site_id}/}"    # Replace guid with URL name
        repo_url="${repo_url//\/2222\/~\/repository/\/${site_name}}"  # Remove goggledegook
    fi
    echo "${repo_url}"
}

function make_cache_dir() {
    cache_dir="$1"
    mkdir --parents "${cache_dir}"
}

function get_raw_repo_cache_dir() {
    declare=${BOX_CACHE_DIR:=}
    local repo_url="$1"
    checkParam "${repo_url}" "You must pass a repository URL as 1st argument to get_raw_repo_cache_dir()."
    exitOnError
    local path="${repo_url}"
    path="${repo_url#*://}"     # Strip leading protocol; ssh://, https://, http://
    path="${path#*@}"    # Strip leading username, e.g. git@
    path="${path%.git*}"        # Strip trailing .git extension
    path="${path/:/\/}"         # Replace ':' with '/'
    local cache_dir="${BOX_CACHE_DIR}/${path}"
    cache_dir="$(simplify_pantheon_repo_cache_dir "${cache_dir}")"
    echo "${cache_dir}"
}

function check_deploy_host() {
    local host_id="$1"
    checkParam "${host_id}" "You must pass a host name/id as 1st argument to check_deploy_host()."
    exitOnError
    echo "$(get_deploy_host "${host_id}")" > /dev/null
}

function get_deploy_host() {
    local host_id="$1"
    checkParam "${host_id}" "You must pass a host name/id as 1st argument to get_deploy_host()."
    exitOnError
    json="$(cat "${BOX_PROJECT_FILE}" | jq -r ".deploy.hosts.${host_id}?")"
    if [ "object" != "$(echo "${json}"|jqr 'type')" ]; then
        alert ""
        alert "ERROR: ${RED}Your ${GREEN}project.json${RED} file does not define a host named ${YELLOW}\"${GREEN}${host_id}${YELLOW}\"${RED}.${RESET}"
        alert ""
        alert "Please edit your ${GREEN}project.json${RESET} file and add ${YELLOW}\"${GREEN}${host_id}${YELLOW}\"${RESET} as a property of ${GREEN}.hosts.${RESET}"
        alert ""
        exit 1
    fi
    echo -e "${json}"
}

function get_source_repo_url() {
    local source_repo_url="$(get_raw_source_repo_url)"
    local remote_repo_url="$(get_git_origin_remote_repo_url)"
    if [[ "${source_repo_url}" =~ ^ssh:// ]]; then
        source_repo_url="${source_repo_url#*//}"
    fi
    if [ "${source_repo_url}" != "${remote_repo_url}" ]; then
        alert ""
        alert "${RED}Your source repo and your git remote repo do not match. Cannot deploy.${RESET}"
        alert ""
        alert "\t${CYAN}Source: ${GREEN}${source_repo_url}${RESET}"
        alert "\t${CYAN}Remote: ${GREEN}${remote_repo_url}${RESET}"
        alert ""
        alert "Your source repo is found in ${GREEN}${BOX_PROJECT_FILE}${RESET} as ${GREEN}.source.repository.url.${RESET}"
        alert "Your remote is found by running ${GREEN}git remote -v${RESET}. If you are in the correct directory you"
        alert "can set your remote to match your source with:"
        alert ""
        alert "\t${GREEN}git remote set-url --push origin ${source_repo_url}${RESET}"
        alert ""
        alert "However, ${GREEN}caution is in order${RESET}. We can only give you hints about how you can resolve"
        alert "this issue, but your circumstances might require another solution, and Git can be"
        alert "a rather unforgiving beast if you do the wrong thing. So measure twice, cut once!${RESET}"
        alert ""
        exit 1
    fi
    echo "${source_repo_url}"
}

function get_source_repo_branch() {
    local host_id="$1"
    local project_branch="$(get_raw_source_branch_by "host" "${host_id}")"
    exitOnError
    local current_branch="$(get_current_git_branch)"
    exitOnError
    if [ "null" == "${project_branch}" ] ; then
        project_branch="n/a"
    fi
    if [ "${current_branch}" != "${project_branch}" ]; then
        alert ""
        alert "${RED}Your current branch does not match the deploy branch for the ${GREEN}${host_id}${RED} host."
        alert "Cannot deploy.${RESET}"
        alert ""
        alert "\t${CYAN}The current Git branch:        ${GREEN}${current_branch}${RESET}"
        alert "\t${CYAN}Host you specified for deploy: ${GREEN}${host_id}${RESET}"
        alert "\t${CYAN}Deploy branch in project.json: ${GREEN}${project_branch}${RESET}"
        alert ""
        if [ "n/a" == "${project_branch}" ] ; then
            alert "${RED}Review your project.json file to ensure you have a host ${GREEN}${host_id}${RED} defined in"
            alert "the ${GREEN}.host${RED} section.${RESET}"
        else
            alert "You can set switch to the branch for the ${GREEN}${host_id}${RESET} host using:"
            alert ""
            alert "\t${GREEN}git checkout ${project_branch}${RESET}"
            alert ""
            alert "The above only works if files in the ${GREEN}${current_branch}${RESET} branch have been committed."
            alert ""
        fi
        alert ""
        exit 1
    fi
    echo "${current_branch}"
}

function ensure_no_uncommitted_files() {
    local uncommitted_files="$(get_git_uncommitted_files)"
    local file
    if [ "" != "${uncommitted_files}" ]; then
        alert ""
        alert "${RED}Your current branch has uncommitted files. Cannot deploy.${RESET}"
        alert ""
        saveIFS="${IFS}"
        IFS=$'\n'
        for file in $uncommitted_files ; do
            alert "\t${GREEN}${file}${RESET}"
        done
        IFS="${saveIFS}"
        alert ""
        exit 1
    fi
}

################################################################################
CMD="$1"
shift
case $CMD in
    'unlock')
        deploy_unlock
        ;;

	*|'help')

        if [ "" == "${CMD}" ] ; then
            deploy_help
            exit 1
        fi
        deploy_host "${CMD}"
		;;
esac

